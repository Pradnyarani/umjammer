#summary Java Reverse Engineering
<g:plusone size="medium"></g:plusone>
= Tools =

  * [http://www.varaneckas.com/jad jad]
   * 長所
    * 今のところ最強
   * 短所
    * Exception 周りが下手、finally は絶望的
    * switch もダメダメ
    * for, while の扱いが逆なんじゃない？
    * inner class もちょっとおかしい
    * synchronize もダメ
    * 開発終了？

  * [http://java.decompiler.free.fr/ JD]
   * 長所
    * Exception はまあまあ
    * switch もまあまあ
     * break が抜けてる気がするのだが
    * 開発中
   * 短所
    * いまいち信用出来ない
     * jad はうまく行かなかったところに byte code っぽいものを残すのだが、JD は適当にエラーのないコードを出力してるような
    * CUI がない

 jad で最初逆コンパイルしておかしいところを JD で補完していくのがいいと思う

= How To =

 面倒になるのが同じ文字で大文字、小文字のクラス名に難読化されている場合、ファイルシステムが対応してないとか、Eclipse が判別してくれないとかあるのでそれを解除する。

 あとメソッドのオーバーロードのバインディングミスも発見しづらいので最初に回避するようにしておく

== Anti Obfuscation ==

 難読化を解除するために難読化ツールを使用する。

 * [http://proguard.sourceforge.net/ ProGuard]
  * method overload を積極的にしているのを解除する (-useuniqueclassmembernames)
  * クラス名に同じ文字の大文字、小文字を許容するも解除 (-dontusemixedcaseclassnames)

{{{
-dontshrink
-dontoptimize
-useuniqueclassmembernames
-dontpreverify
-keepparameternames
-renamesourcefileattribute SourceFile
-keepattributes Exceptions,InnerClasses,Signature,Deprecated,
                SourceFile,LineNumberTable,*Annotation*,EnclosingMethod

-keeppackagenames your.packages.**

-keepnames class your.packages.**
}}}

== Decompile ==

 * jad
  * オーバーロードのバインドミスを無くすために -safe オプションを付ける

{{{
 $ find . -name \*.class -exec jad -s .java -safe -space -r -nonlb -ff {} \;
}}}

== Hand Completion ==

=== for ===

 * パターンでわかる


{{{
        i = 0;
          goto _L1
_L3:

         :

        i++;
_L1:
        if (i < 10) goto _L3; else goto _L2
_L2:

}}}

{{{

    for (i = 0; i < 10; i++) {
        :
    }
}}}

=== exception ===

 * 何となく分かる、try がどこに入るのかがいまいちよくわからない

=== finally ===

 * exception 処理っぽいところで同じコードが何回も出てきたらそれは finally 節

{{{
        break MISSING_BLOCK_LABEL_43;
        Exception exception;
        exception;
        a.c();
        throw exception;
        a.c();
        return;
}}}

{{{
        } catch (Exception exception) {
        } finally {
            a.c();
        }
}}}

=== switch ===

 * 人力ではキツイので JD に頼る

{{{
        a;
        JVM INSTR tableswitch -1 6: default 523
    //                   -1 523
    //                   0 60
    //                   1 200
    //                   2 523
    //                   3 499
    //                   4 499
    //                   5 507
    //                   6 515;
           goto _L1 _L1 _L2 _L3 _L1 _L4 _L4 _L5 _L6
_L2:
           :
}}}

=== synchronized ===

 * パターンでわかる

{{{
        Object obj = foo;
        JVM INSTR monitorenter ;
          :
        obj;
        JVM INSTR monitorexit ;
        throw ;
}}}

{{{
    synchronized(foo) {
        :
    }
}}}

=== inner class ===

 * コンストラクタで super の場所が間違ってるので直す。
 * 親クラス参照を消す
 * コンパイラが作成したと思われる static メソッドをインライン化する


{{{
    
        foo.addActionListener(new g(this));

      :

    static void a(BaseClass a, String s) {
        System.out.println(s);
    }

    class g
        implements ActionListener {

        final BaseClass a;

        public void actionPerformed(ActionEvent actionevent) {
            BaseClass.a(a, "");
        }

            g() {
                a = BaseClass.this;
                super();
            }
    }

}}}

{{{
        foo.addActionListener(new g());

      :

    class g
        implements ActionListener {

        public void actionPerformed(ActionEvent actionevent) {
            System.out.println(s);
        }

            g() {
                super();
            }
    }
}}}

さらに進めて

{{{
        foo.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent actionevent) {
                System.out.println(s);
            }
        });
}}}

=== class ===

 * 表記が変なので直す

{{{
        a = (new Class[] {
            0,
            java/lang/String,
            java/lang/Integer,
            [Ljava/lang/Object;,
            java/lang/Object,
            [I,
            [D,
        });
}}}

{{{
        a = (new Class[] {
            null,
            java.lang.String.class,
            java.lang.Integer.class,
            java.lang.Object[].class,
            java.lang.Object.class,
            int[].class,
            double[].class,
        });
}}}

=== String ===

 * StringBuilder、StringBuffer を消す

{{{
  System.err.println((new StringBuilder("value: ")).append(value).toString());
}}}

{{{
  System.err.println("value: " + value);
}}}

=== local variables created by compiler ===

 * 見やすくしたり、消したり
 * while の条件式中のやつは注意

=== double literal ===

 * 人が書いた数値に戻す

{{{
    double d1 = 0.29999999999999999D;
}}}

{{{
    double d1 = 0.3d;
}}}

= Others =

Eclipse のリファクタリング機能がこれほど活躍できる場面はないと思う。

たまに Javadoc だけ公開されている場合がある。その場合は [http://codavaj.sourceforge.net/ Codavaj] を使用すればコピペで楽にコメントが付けられる。おまけに正しい引数名が得られるので、そこから芋づる式に内部の解析が進むこともある。

慣れてくると、ああこれ jad のソースだとわかるようになる。例えば [http://java.net/projects/jflash/sources/svn/content/trunk/prj/jflash/src/org/jflash/DisplayList.java?rev=38 jflash] の 508 行目とか [http://code.google.com/p/umjammer/w/edit.do#local_variables_created_by_compiler local variables created by compiler] に相当するのがわかる。それ以前に変数名でわかっちゃうけどね。よくもまあ抜け抜けとリバエンしたやつをメジャーサイトに公開するよなぁ？

= Todo =

オーバーロードでミスる事を知らなかったときにリバエンした 50000 行くらいのコードがあるのだが、もちろんエラーは出ないし、なんとちゃんと動いてしまってるので、どこでミスってるのかが簡単に検出できない。結果のデータが違うので明らかにミスっているのは分かるのだが、~~どうしたものか...~~

 * ~~call graph 作成とか？~~ → はっきり言ってムリ

== 見つけた ==

オーバーロードのミスより、名前の優先順位が定数より変数が勝つみたいなのでそこがミスっていた
null と比較とかだとエラーにならない場合が出てくる。

{{{
   class Foo {
      Bar a;
   }

   class a {
      public static Foo a;
   }

   class b {
      Foo a;
      
      ... {
         if (a.a != null) { ... // compiler recognizes class b's field a (class Foo) 's field a,
                                     // but real source was class a's static field a
      }
   }
}}}

まあ [http://code.google.com/p/umjammer/wiki/JavaReverseEngineering?ts=1316976443&updated=JavaReverseEngineering#Anti_Obfuscation Anti_Obfuscation] しておけばいらない苦労だったんだけどね。